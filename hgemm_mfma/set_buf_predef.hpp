// generated by gen_set_buf.py
template <typename T/*sizeof(T)==4*/, index_t N, bool disable_inline_asm = false, bool use_dwordx2 = (sizeof(T) == 8)>
struct set_static_array_dword {
    template<index_t value = 0>
    DEVICE void operator()(static_buffer<T, N> & vec, number<value> = number<0>{}) {
#if !USE_C_ARRAY
        constexpr_for<0, N, 1>{}([&](auto i){
            vec[i] = static_cast<T>(value);
        });
#else
        for(auto i = 0; i < N; i++)
             vec[i] = static_cast<T>(value);
#endif
    }
};

template <typename T, index_t N> struct set_static_array_dword<T, N, false/*disable_inline_asm*/, true> {
    template<index_t value = 0>
    DEVICE void operator()(static_buffer<T, N> & vec, number<value> = number<0>{}) {
        static_assert(sizeof(T) == 8);
#if !USE_C_ARRAY
        constexpr_for<0, N, 1>{}([&](auto i_n){
            auto & vec_wa = vec;
            asm volatile( "v_pk_mov_b32 %0, %1, %1 op_sel:[0, 1]" : "=v"(vec_wa[i_n]) : "n"(value) );
        });
#else
        for(auto i = 0; i < N; i++)
             asm volatile( "v_pk_mov_b32 %0, %1, %1 op_sel:[0, 1]" : "=v"(vec[i]) : "n"(value) );
#endif
    }
};

template <typename T, index_t N> struct set_static_array_dword<T, N, false/*disable_inline_asm*/, false> {
    template<index_t value = 0>
    DEVICE void operator()(static_buffer<T, N> & vec, number<value> = number<0>{}) {
        static_assert(sizeof(T) == 4);
#if !USE_C_ARRAY
        constexpr_for<0, N, 1>{}([&](auto i_n){
            auto & vec_wa = vec;
            asm volatile( "v_mov_b32 %0, %1" : "=v"(vec_wa[i_n]): "n"(value) );
        });
#else
        for(auto i =0; i < N; i++)
            asm volatile( "v_mov_b32 %0, %1" : "=v"(vec[i]): "n"(value) );
#endif
    }
};

// generated by gen_set_buf.py
template <typename T, index_t N, bool disable_inline_asm = false, index_t SET_BY_DWORD = (sizeof(T) * N % 8 == 0 && sizeof(T) <= 8) ? 2 : ((sizeof(T) * N % 4 == 0 && sizeof(T) <= 4) ? 1 : 0)>
struct set_buf;
template <typename T, index_t N, bool disable_inline_asm>
struct set_buf<T, N, disable_inline_asm, 0> {
    template<index_t value = 0>
    DEVICE void operator()(vector_type<T, N> & vec, number<value> = number<0>{}) {
        constexpr_for<0, N, 1>{}([&](auto i){
            vec.template to_varray<T>()[i] = static_cast<T>(value);
        });
    }
};
template <typename T, index_t N, bool disable_inline_asm>
struct set_buf<T, N, disable_inline_asm, 1> {
    template<index_t value = 0>
    DEVICE void operator()(vector_type<T, N> & vec, number<value> = number<0>{}) {
        using dword_t = typename vector_type<T, 4 / sizeof(T)>::type;
        set_static_array_dword<dword_t, N * sizeof(T) / 4, disable_inline_asm>{}(vec.template to_varray<dword_t>(), number<value>{});
    }
};
template <typename T, index_t N, bool disable_inline_asm>
struct set_buf<T, N, disable_inline_asm, 2> {
    template<index_t value = 0>
    DEVICE void operator()(vector_type<T, N> & vec, number<value> = number<0>{}) {
        using dword_t = typename vector_type<T, 8 / sizeof(T)>::type;
        set_static_array_dword<dword_t, N * sizeof(T) / 8, disable_inline_asm>{}(vec.template to_varray<dword_t>(), number<value>{});
    }
};

